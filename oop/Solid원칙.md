Solid 원칙
========================

**1. SRP(Single Responsibility Principle) : 단일 책임 원칙**

클래스와 함수 등의 소프트웨어 설계 부품은 단 하나의 책임만을 가져야 한다.   
설계를 잘한 소프트웨어는 응집도는 높고 결합도는 낮은 프로그램이다.   
클래스가 수행할 수 있는 기능이 많아지면 클래스 내부 함수끼리 강한 결합이 발생할 가능성이 높다.   
즉, 한 책임을 변경시키기 위해 다른 책임과 관련된 함수를 변경시켜 유지보수 비용을 증가시킬 수 있다.    
  
  

**2. OCP(Open-Closed Principle) : 개방-폐쇄 원칙**

(closed) 기존의 코드를 변경하지 않고
(open) 기능을 수정하거나 추가할 수 있도록 설계해야 한다.   
변경되는 것에 초점을 맞춰 자주 변경되는 내용은 수정하기 쉽도록 설계해야 한다.   
Java에서는 주로 interface를 정의하고 하위 클래스에서 오버라이딩하도록 설계하는 것이 예시이다.

**3. LSP(Liskov Substitution Principle) : 리스코프 치환 원칙**

자식클래스는 부모클래스에서 가능한 행위를 수행할 수 있어야 한다.   
부모클래스와 자식클래스 사이의 행위에는 일관성이 있어야 하며,    
부모클래스의 인스턴스 대신 자식클래스의 인스턴스를 사용해도 문제가 없어야 한다.   
상속 관계에서는 일반화 관계(IS-A)가 성립해야 한다.   
   
**4. DIP(Dependency Inversion Principle) : 의존 역전 원칙**

의존 관계를 맺을 때, 변화하기 쉬운것 보단 변화하기 어려운 것에 의존해야 한다는 원칙이다.   
변화하기 쉬운 것이란 구체적인 것이고 변화하기 어려운 것은 추상적인 것이다.   
즉 의존관계를 맺을 때, 구체적인 클래스보다 추상클래스나 인터페이스와 관계를 맺는다는 것을 의미한다.   
생성자를 통해 사용할 객체를 전달받도록 하는 '의존성 주입'을 통해 변화에 유연한 설계를 할 수 있다.

**5. ISP(Interface Segregation Principle) : 인터페이스 분리 원칙**

인터페이스는 그 인터페이스를 사용하는 클라이언트를 기준으로 분리해야 한다.   
즉, 자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다는 설계 원칙이다.   
하나의 거대한 인터페이스 보다는 여러 개의 구체적인 인터페이스가 낫다는 것을 의미한다.   
각 클라이언트가 필요로 하는 인터페이스들만 분리함으로써 사용하지 않는 인터페이스에 변경이 발생해도 영향을 받지 않아야 한다.   
